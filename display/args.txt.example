Processing Arguments [--cwd,/home/alex/temp/HaxeRepro,build.hxml,-hl,export/run.hl,-cmd,hl export/run.hl,-D,display-details,--no-output,--display,{"jsonrpc":"2.0","id":1874,"method":"display/completion","params":{"file":"/home/alex/Work/HaXe/haxe/std/hl/_std/sys/net/Socket.hx","contents":"/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage sys.net;\nimport haxe.io.Error;\n\n#if doc_gen\n@:noDoc enum SocketHandle { }\n#else\n@:noDoc typedef SocketHandle = hl.Abstract<\"hl_socket\">;\n#end\n\nprivate class SocketOutput extends haxe.io.Output {\n\n\tvar sock : Socket;\n\n\tpublic function new(s) {\n\t\tthis.sock = s;\n\t}\n\n\tpublic override function writeByte( c : Int ) {\n\t\tvar k = socket_send_char(@:privateAccess sock.__s, c);\n\t\tif( k < 0 ) {\n\t\t\tif( k == -1 ) throw Blocked;\n\t\t\tthrow new haxe.io.Eof();\n\t\t}\n\t}\n\n\tpublic override function writeBytes( buf : haxe.io.Bytes, pos : Int, len : Int) : Int {\n\t\tif( pos < 0 || len < 0 || pos + len > buf.length ) throw haxe.io.Error.OutsideBounds;\n\t\tvar n = socket_send(@:privateAccess sock.__s, buf.getData().bytes, pos, len);\n\t\tif( n < 0 ) {\n\t\t\tif( n == -1 ) throw Blocked;\n\t\t\tthrow new haxe.io.Eof();\n\t\t}\n\t\treturn n;\n\t}\n\n\tpublic override function close() {\n\t\tsock.close();\n\t}\n\n\n\t@:hlNative(\"std\",\"socket_send_char\") static function socket_send_char( s : SocketHandle, c : Int ) : Int { return 0; }\n\t@:hlNative(\"std\",\"socket_send\") static function socket_send( s : SocketHandle, bytes : hl.Bytes, pos : Int, len : Int ) : Int { return 0; }\n\n}\n\nprivate class SocketInput extends haxe.io.Input {\n\n\tvar sock : Socket;\n\n\tpublic function new(s) {\n\t\tsock = s;\n\t}\n\n\tpublic override function readByte() : Int {\n\t\tvar c = socket_recv_char(@:privateAccess sock.__s);\n\t\tif( c < 0 ) {\n\t\t\tif( c == -1 ) throw Blocked;\n\t\t\tthrow new haxe.io.Eof();\n\t\t}\n\t\treturn c;\n\t}\n\n\tpublic override function readBytes( buf : haxe.io.Bytes, pos : Int, len : Int ) : Int {\n\t\tif( pos < 0 || len < 0 || pos + len > buf.length ) throw haxe.io.Error.OutsideBounds;\n\t\tvar r = socket_recv(@:privateAccess sock.__s,buf.getData().bytes,pos,len);\n\t\tif( r <= 0 ) {\n\t\t\tif( r == -1 ) throw Blocked;\n\t\t\tthrow new haxe.io.Eof();\n\t\t}\n\t\treturn r;\n\t}\n\n\tpublic override function close() {\n\t\tsock.close();\n\t}\n\n\t@:hlNative(\"std\",\"socket_recv\") static function socket_recv( s : SocketHandle, bytes : hl.Bytes, pos : Int, len : Int ) : Int { return 0; }\n\t@:hlNative(\"std\",\"socket_recv_char\") static function socket_recv_char( s : SocketHandle ) : Int { return 0; }\n\n}\n\n@:coreApi\n@:keepInit\nclass Socket {\n\n\tprivate var __s : SocketHandle;\n\tpublic var input(default,null) : haxe.io.Input;\n\tpublic var output(default,null) : haxe.io.Output;\n\tpublic var custom : Dynamic;\n\n\tstatic function __init__() : Void {\n\t\tsocket_init();\n\t\t\n\t}\n\n\tpublic function new() : Void {\n\t\tinit();\n\t}\n\n\tfunction init() : Void {\n\t\tif( __s == null ) __s = socket_new(false);\n\t\tinput = new SocketInput(this);\n\t\toutput = new SocketOutput(this);\n\t}\n\n\tpublic function close() : Void {\n\t\tif( __s != null ) {\n\t\t\tsocket_close(__s);\n\t\t\t__s = null;\n\t\t}\n\t}\n\n\tpublic function read() : String {\n\t\treturn input.readAll().toString();\n\t}\n\n\tpublic function write( content : String ) : Void {\n\t\toutput.writeString(content);\n\t}\n\n\tpublic function connect(host : Host, port : Int) : Void {\n\t\tif( !socket_connect(__s, host.ip, port) )\n\t\t\tthrow new Sys.SysError(\"Failed to connect on \"+host.toString()+\":\"+port);\n\t}\n\n\tpublic function listen( connections : Int ) : Void {\n\t\tif( !socket_listen(__s, connections) )\n\t\t\tthrow new Sys.SysError(\"listen() failure\");\n\t}\n\n\tpublic function shutdown( read : Bool, write : Bool ) : Void {\n\t\tif( !socket_shutdown(__s, read, write) )\n\t\t\tthrow new Sys.SysError(\"shutdown() failure\");\n\t}\n\n\tpublic function bind(host : Host, port : Int) : Void {\n\t\tif( !socket_bind(__s, host.ip, port) )\n\t\t\tthrow new Sys.SysError(\"Cannot bind socket on \" + host + \":\" + port);\n\t}\n\n\tpublic function accept() : Socket {\n\t\tvar c = socket_accept(__s);\n\t\tif( c == null )\n\t\t\treturn null;\n\t\tvar s : Socket = untyped $new(Socket);\n\t\ts.__s = c;\n\t\ts.input = new SocketInput(s);\n\t\ts.output = new SocketOutput(s);\n\t\treturn s;\n\t}\n\n\tpublic function peer() : { host : Host, port : Int } {\n\t\tvar ip = 0, port = 0;\n\t\tif( !socket_peer(__s, ip, port) )\n\t\t\treturn null;\n\t\tvar h : Host = untyped $new(Host);\n\t\t@:privateAccess h.ip = ip;\n\t\treturn { host : h, port : port };\n\t}\n\n\tpublic function host() : { host : Host, port : Int } {\n\t\tvar ip = 0, port = 0;\n\t\tif( !socket_host(__s, ip, port) )\n\t\t\treturn null;\n\t\tvar h : Host = untyped $new(Host);\n\t\t@:privateAccess h.ip = ip;\n\t\treturn { host : h, port : port };\n\t}\n\n\tpublic function setTimeout( timeout : Float ) : Void {\n\t\tif( !socket_set_timeout(__s, timeout) ) throw new Sys.SysError(\"setTimeout() failure\");\n\t}\n\n\tpublic function waitForRead() : Void {\n\t\tselect([this],null,null,null);\n\t}\n\n\tpublic function setBlocking( b : Bool ) : Void {\n\t\tif( !socket_set_blocking(__s, b) ) throw new Sys.SysError(\"setBlocking() failure\");\n\t}\n\n\tpublic function setFastSend( b : Bool ) : Void {\n\t\tif( !socket_set_fast_send(__s,b) ) throw new Sys.SysError(\"setFastSend() failure\");\n\t}\n\n\t// TODO : use TLS when multithread added\n\tstatic var tmp : hl.Bytes = null;\n\tstatic var curTmpSize = 0;\n\n\tstatic function makeArray( a : Array<Socket> ) : hl.NativeArray<SocketHandle> {\n\t\tif( a == null ) return null;\n\t\tvar arr = new hl.NativeArray(a.length);\n\t\tfor( i in 0...a.length )\n\t\t\tarr[i] = a[i].__s;\n\t\treturn arr;\n\t}\n\n\tstatic function outArray( a : hl.NativeArray<SocketHandle>, original : Array<Socket> ) : Array<Socket> {\n\t\tvar out = [];\n\t\tif( a == null ) return out;\n\t\tvar i = 0, p = 0;\n\t\tvar max = original.length;\n\t\twhile( i < max ) {\n\t\t\tvar sh = a[i++];\n\t\t\tif( sh == null ) break;\n\t\t\twhile( original[p].__s != sh ) p++;\n\t\t\tout.push(original[p++]);\n\t\t}\n\t\treturn out;\n\t}\n\n\tpublic static function select(read : Array<Socket>, write : Array<Socket>, others : Array<Socket>, ?timeout : Float) : {read: Array<Socket>, write: Array<Socket>, others: Array<Socket>} {\n\t\tvar sread = makeArray(read);\n\t\tvar swrite = makeArray(write);\n\t\tvar sothers = makeArray(others);\n\t\tvar tmpSize = 0;\n\t\tif( sread != null ) tmpSize += socket_fd_size(sread.length);\n\t\tif( swrite != null ) tmpSize += socket_fd_size(swrite.length);\n\t\tif( sothers != null ) tmpSize += socket_fd_size(sothers.length);\n\t\tif( tmpSize > curTmpSize ) {\n\t\t\ttmp = new hl.Bytes(tmpSize);\n\t\t\tcurTmpSize = tmpSize;\n\t\t}\n\t\tif( !socket_select(sread, swrite, sothers, tmp, curTmpSize, timeout == null ? -1 : timeout) )\n\t\t\tthrow \"Error while waiting on socket\";\n\t\treturn {\n\t\t\tread : outArray(sread,read),\n\t\t\twrite : outArray(swrite,write),\n\t\t\tothers : outArray(sothers,others),\n\t\t};\n\t}\n\n\t@:hlNative(\"std\", \"socket_init\") static function socket_init() : Void {}\n\t@:hlNative(\"std\", \"socket_new\") static function socket_new( udp : Bool ) : SocketHandle { return null; }\n\t@:hlNative(\"std\", \"socket_close\") static function socket_close( s : SocketHandle ) : Void { }\n\t@:hlNative(\"std\", \"socket_connect\") static function socket_connect( s : SocketHandle, host : Int, port : Int ) : Bool { return true; }\n\t@:hlNative(\"std\", \"socket_listen\") static function socket_listen( s : SocketHandle, count : Int ) : Bool { return true; }\n\t@:hlNative(\"std\", \"socket_bind\") static function socket_bind( s : SocketHandle, host : Int, port : Int ) : Bool { return true; }\n\t@:hlNative(\"std\", \"socket_accept\") static function socket_accept( s : SocketHandle ) : SocketHandle { return null; }\n\t@:hlNative(\"std\", \"socket_peer\") static function socket_peer( s : SocketHandle, host : hl.Ref<Int>, port : hl.Ref<Int> ) : Bool { return true; }\n\t@:hlNative(\"std\", \"socket_host\") static function socket_host( s : SocketHandle, host : hl.Ref<Int>, port : hl.Ref<Int> ) : Bool { return true; }\n\t@:hlNative(\"std\", \"socket_set_timeout\") static function socket_set_timeout( s : SocketHandle, timeout : Float ) : Bool { return true; }\n\t@:hlNative(\"std\", \"socket_shutdown\") static function socket_shutdown( s : SocketHandle, read : Bool, write : Bool ) : Bool { return true; }\n\t@:hlNative(\"std\", \"socket_set_blocking\") static function socket_set_blocking( s : SocketHandle, b : Bool ) : Bool { return true; }\n\t@:hlNative(\"std\", \"socket_set_fast_send\") static function socket_set_fast_send( s : SocketHandle, b : Bool ) : Bool { return true; }\n\n\t@:hlNative(\"std\", \"socket_fd_size\") static function socket_fd_size( count : Int) : Int { return 0; }\n\t@:hlNative(\"std\", \"socket_select\") static function socket_select( read : hl.NativeArray<SocketHandle>, write : hl.NativeArray<SocketHandle>, other : hl.NativeArray<SocketHandle>, tmpData : hl.Bytes, tmpSize : Int, timeout : Float ) : Bool { return false; }\n\n}\n","offset":3490,"wasAutoTriggered":false}}]